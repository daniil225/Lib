/********************************************************************************************************************************/
// Реализация Структуры данных Красно-Черное дерево. Все алгоритмы взяты из книги Т.Кормен Алгоритмы построение и анализ 3-е издание Глава 13
// Структуры и прототипы функции структуры данных : Красно-Черное дерево
/************************************************************  END  *************************************************************/
#ifndef RB_TREE_H_
#define RB_TREE_H_


// Размер структуры Node в байтах
// SIZE_NODE == sizeof(struct Node);
#define SIZE_NODE 40

/****************************************  Объявление структуры дерева  ***********************************************/

enum Color
{
    BLACK, // 0
    RED // 1
};

struct Node
{
    enum Color color;
    struct Node *p;
    struct Node *left;
    struct Node *right;
    int key;
};


struct Rb_Tree
{
    struct Node *nil; // Представляет собой точно такое же элемент с теми же атрибутами что и обычный элемент дерева color = BLACK
    // А все остальные атрибуты имеют произвольное значение
    // left == NULL right - указатель на root
    struct Node *root;
    int size;
};



/****************************************************   END  ****************************************************************/


/*******************************************  Функции для работы с деревом   ***********************************************/


// Инициализация структуры дерева
 void InitRBTree(struct Rb_Tree *rbtree);


//////////////////////////////////////////////////////////////////////////////////////////////
// Достаточно проблемно понимается сама суть операции, однако является довольно элементарной
// В силу сложности пониманию подробное описание будет находиться в папке Documents/help.pdf
// В файле представлено подробное описание каждого шага алгоритма 

// Левый поворот дерева
void LeftRotate(struct Rb_Tree *rbtree, struct Node *x);
// Правый поворот дерева
void RightRotate(struct Rb_Tree *rbtree, struct Node *x);
//////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////
// Операция вставки элемента в дерево
// В силу сложности пониманию подробное описание будет находиться в папке Documents/help.pdf
void RbInsert(struct Rb_Tree *rbtree, struct Node *z);
void RbInsertFixUp(struct Rb_Tree *rbtree, struct Node *z);
//////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////

// Операции удаления элемента из дерева
void RbTransplant(struct Rb_Tree *rbtree, struct Node* u,struct Node *v);
struct Node* TreeMin(struct Node *nil,struct Node *x);
void RbDelete(struct Rb_Tree *rbtree, struct Node* z);
void RbDeleteFixUp(struct Rb_Tree *rbtree, struct Node* z); 

/////////////////////////////////////////////////////////////////////////////////////////////



// Стандартный алгоритм поиска элемента в дереве
struct Node* find(struct Rb_Tree *rbtree, int key);

/************************************************************ END ***********************************************************/


/**********************************  Вспомогательные функции   **************************************************************/

// param: int flag
// 0 - Вывод элементов дерева в порядке (левое-корень-правое) без подробной распечатки адресов всех элементов
// 1 - ---------------------------||------------------------- c подробным выводом всех адресов элементов дерева
void PrintTree(struct Node* nil,struct Node const *rbtree, int flag);

struct Node *MakeNode(int key);


/************************************************************  END  ********************************************************/

#endif